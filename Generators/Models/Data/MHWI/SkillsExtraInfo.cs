// <auto-generated />
	using System.Globalization;
	using Newtonsoft.Json;
	using Newtonsoft.Json.Converters;
namespace MediawikiTranslator.Models.Data.MHWI
{

	public partial class SkillsExtraInfo
	{
		[JsonProperty("Name", NullValueHandling = NullValueHandling.Ignore)]
		public string Name { get; set; }

		[JsonProperty("Id", NullValueHandling = NullValueHandling.Ignore)]
		[JsonConverter(typeof(SkillsExtraInfoParseStringConverter))]
		public long? Id { get; set; }

		[JsonProperty("Is Set Bonus", NullValueHandling = NullValueHandling.Ignore)]
		public IsSetBonus? IsSetBonus { get; set; }

		[JsonProperty("Icon Color ID", NullValueHandling = NullValueHandling.Ignore)]
		[JsonConverter(typeof(SkillsExtraInfoParseStringConverter))]
		public long? IconColorId { get; set; }

		[JsonProperty("Wiki Icon Color", NullValueHandling = NullValueHandling.Ignore)]
		public string WikiIconColor { get; set; }
	}

	public enum IsSetBonus { False, True };

	public partial class SkillsExtraInfo
	{
		public static SkillsExtraInfo[] FromJson(string json) => JsonConvert.DeserializeObject<SkillsExtraInfo[]>(json, MediawikiTranslator.Models.Data.MHWI.SkillsExtraInfoConverter.Settings);
	}

	public static class SkillsExtraInfoSerialize
	{
		public static string ToJson(this SkillsExtraInfo[] self) => JsonConvert.SerializeObject(self, MediawikiTranslator.Models.Data.MHWI.SkillsExtraInfoConverter.Settings);
	}

	internal static class SkillsExtraInfoConverter
	{
		public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
		{
			MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
			DateParseHandling = DateParseHandling.None,
			Converters =
			{
				IsSetBonusConverter.Singleton,
				new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
			},
		};
	}

	internal class SkillsExtraInfoParseStringConverter : JsonConverter
	{
		public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

		public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null) return null;
			var value = serializer.Deserialize<string>(reader);
			long l;
			if (Int64.TryParse(value, out l))
			{
				return l;
			}
			throw new Exception("Cannot unmarshal type long");
		}

		public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
		{
			if (untypedValue == null)
			{
				serializer.Serialize(writer, null);
				return;
			}
			var value = (long)untypedValue;
			serializer.Serialize(writer, value.ToString());
			return;
		}

		public static readonly SkillsExtraInfoParseStringConverter Singleton = new SkillsExtraInfoParseStringConverter();
	}

	internal class IsSetBonusConverter : JsonConverter
	{
		public override bool CanConvert(Type t) => t == typeof(IsSetBonus) || t == typeof(IsSetBonus?);

		public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null) return null;
			var value = serializer.Deserialize<string>(reader);
			switch (value)
			{
				case "FALSE":
					return IsSetBonus.False;
				case "TRUE":
					return IsSetBonus.True;
			}
			throw new Exception("Cannot unmarshal type IsSetBonus");
		}

		public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
		{
			if (untypedValue == null)
			{
				serializer.Serialize(writer, null);
				return;
			}
			var value = (IsSetBonus)untypedValue;
			switch (value)
			{
				case IsSetBonus.False:
					serializer.Serialize(writer, "FALSE");
					return;
				case IsSetBonus.True:
					serializer.Serialize(writer, "TRUE");
					return;
			}
			throw new Exception("Cannot marshal type IsSetBonus");
		}

		public static readonly IsSetBonusConverter Singleton = new IsSetBonusConverter();
	}
}
